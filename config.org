#+options: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: config
#+date: <2020-05-14 Thu>
#+author: Enze Chi
#+email: Enze.Chi@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 26.3 (Org mode 9.4)
#+startup: overview
#+property: header-args:emacs-lisp+ :tangle "yes"

* User Information
#+begin_src emacs-lisp
(setq user-full-name "Enze Chi")
(setq user-mail-address (getenv "MY_EMAIL"))
#+end_src

* Better defaults

** Simple settings
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 tab-width 4                                      ; Set width for tabs
 uniquify-buffer-name-style 'forward              ; Uniquify buffer names
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      inhibit-compacting-font-caches t            ; When there are lots of glyphs, keep them in memory
      truncate-string-ellipsis "â€¦")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(delete-selection-mode 1)                         ; Replace selection when inserting text
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

** Windows
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Use *ivy* to choose buffer after window split.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (+ivy/switch-buffer))
#+end_src

* Appearance
** Fonts

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Go Mono for Powerline" :size 9))

(when window-system
  (if (> (x-display-pixel-width) 2000)
      (setq doom-font (font-spec :family "Go Mono for Powerline" :size 22))
    (setq doom-font (font-spec :family "Go Mono for Powerline" :size 10))))

#+end_src

** Display time with date
Display date and time in 24h format.
#+begin_src emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-day-and-date t)
(display-time-mode t)
#+end_src

** Full screen at startup
#+begin_src emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

* Key bindings
I do not use *evil-escape* and disable it by default.
#+begin_src emacs-lisp
(after! evil
  (evil-escape-mode nil))
#+end_src

Change local leader key to =,=.

#+begin_src emacs-lisp
(setq doom-localleader-key ",")
#+end_src

Show =which-key= window faster.
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5)
#+end_src

* Languages
** Go
Format code before save.
#+begin_src emacs-lisp
(after! go-mode
  (add-hook! 'before-save-hook #'gofmt-before-save))
#+end_src

** Org
*** Pre-load
Set the base variables before load org-mode.
#+begin_src emacs-lisp
(setq org-directory (expand-file-name "org" (getenv "HOME")))
(setq org-agenda-files (list org-directory))

(setq org-roam-directory (expand-file-name "roam" org-directory))
(add-to-list 'org-agenda-files org-roam-directory)
#+end_src

*** Clock
**** Automatic clock-out
Automatic clock-out when Emacs is idle for 5 mins
#+begin_src emacs-lisp
(after! org
  (setq org-clock-auto-clockout-timer 300)
  (org-clock-auto-clockout-insinuate))
#+end_src
*** Appearance
**** Turn on org-table-header-mode by default
#+begin_src emacs-lisp
(setq org-table-header-line-p t)
#+end_src
**** Pretty tags
#+begin_src emacs-lisp :tangle packages.el
(package! org-pretty-tags)
#+end_src

*** Review
**** Capture templates
Add review capture template.
#+begin_src emacs-lisp
(after! org-capture
  (setq ec/org-capture-review-file (expand-file-name "reviews.org" org-directory))
  (mapc (lambda (template)
          (add-to-list 'org-capture-templates template))
        '(("r" "Review")
          ("rw" "Weekly" entry (file+olp+datetree ec/org-capture-review-file "Weekly") "* %U\n%?" :tree-type week)
          ("rm" "Monthly" entry (file+olp+datetree ec/org-capture-review-file "Monthly") "* %U\n%?")
          ("ry" "Yearly" entry (file+olp+datetree ec/org-capture-review-file "Yearly") "* %U\n%?")
          ("g" "Grab" entry (file+headline +org-capture-notes-file "Grab") "* %? \n%i\n" :prepend t :create t))))
#+end_src

**** Helper functions
***** Open review file in other window
#+begin_src emacs-lisp
(after! org
  (defun ec/open-review-in-other-window ()
    "Open review org file in other-window."
    (interactive)
    (find-file-other-window ec/org-capture-review-file)))
#+end_src

*** Babel
**** http
Make http request within org-mode babel with [[https://github.com/zweifisch/ob-http][ob-http]].

#+begin_src emacs-lisp :tangle packages.el
(package! ob-http
  :recipe (:host github
           :repo "zweifisch/ob-http"))
#+end_src

#+begin_src emacs-lisp
(use-package! ob-http
  :commands (org-babel-execute:http)
  :init
  (after! org
    (add-to-list 'org-babel-load-languages '(http . t))))
#+end_src

#+begin_src http :pretty :tangle no
GET https://www.google.com
#+end_src

*** Log & Drawer
#+begin_src emacs-lisp
(after! org
  (setq org-log-into-drawer t
        org-log-state-notes-into-drawer t
        org-log-done 'time
        org-log-repeat 'time
        org-log-redeadline 'note
        org-log-reschedule 'note))
#+end_src

*** Property
#+begin_src emacs-lisp
(after! org
  (setq org-use-property-inheritance t
        org-catch-invisible-edits 'smart))
#+end_src

*** Agenda
#+begin_src emacs-lisp
(after! org
  (add-to-list 'org-modules 'org-habit)
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t))
#+end_src

Add "*.org.gpg" to agenda file list.
#+begin_src emacs-lisp
(after! org
  (unless (string-match-p "\\.gpg" org-agenda-file-regexp)
    (setq org-agenda-file-regexp
          (replace-regexp-in-string "\\\\\\.org" "\\\\.org\\\\(\\\\.gpg\\\\)?"
                                    org-agenda-file-regexp))))
#+end_src

Add agenda command for weekly review.
#+begin_src emacs-lisp
(after! org-agenda
  (setq org-agenda-custom-commands
        '(("r" . "Review")
          ("rw" "Completed and/or deferred tasks from previous week"
           ((agenda "" ((org-agenda-span 7)
                        (org-agenda-start-day "-7d")
                        (org-agenda-show-log t))))
           ((org-agenda-compact-blocks t))))))
#+end_src

**** Try out super agenda
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src

*** Capture

**** Declarative Org Capture Templates (doct)
#+begin_src emacs-lisp :tangle packages.el
(package! doct
  :recipe (:host github :repo "progfolio/doct"))
#+end_src

#+begin_src emacs-lisp
(use-package! doct
  :commands (doct))
#+end_src

*** Export
Enable syntax highlight for exported source blocks with =minted=.
#+begin_src emacs-lisp
(after! org
  (setq org-latex-listings 'minted)
  (setq org-latex-packages-alist '(("" "minted"))))
#+end_src

*** Roam
Add =roam= capture template.
#+begin_src emacs-lisp
(after! org-roam
  (map! (:localleader
         :map org-mode-map
         :desc "jump to index" "mj" #'org-roam-jump-to-index)
        :map doom-leader-notes-map
        :desc "jump to index" "rj" #'org-roam-jump-to-index)
  (setq org-roam-ref-capture-templates
        '(("r" "ref" plain (function org-roam-capture--get-point)
           "%?"
           :file-name "websites/${slug}"
           :head "#+TITLE: ${title}
    ,#+ROAM_KEY: ${ref}
    - source :: ${ref}"
           :unnarrowed t))))
#+end_src

**** org-roam-server
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-server)
#+end_src

#+begin_src emacs-lisp
(use-package! org-roam-server
  :after org-roam
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8078
        org-roam-server-export-inline-images t
        org-roam-server-authenticate nil
        org-roam-server-label-truncate t
        org-roam-server-label-truncate-length 60
        org-roam-server-label-wrap-length 20)
  (defun org-roam-server-open()
    "Open org-roam server in browser."
    (interactive)
    (browse-url-default-browser (format "http://localhost:%d" org-roam-server-port)))
  (map! (:localleader
         :map org-mode-map
         :desc "Open server" "mso" #'org-roam-server-open)
        :map doom-leader-notes-map
        :desc "Open server" "rso" #'org-roam-server-open)
  (org-roam-server-mode 1))
#+end_src

*** TODOs
#+begin_src emacs-lisp
(after! org
  (setq org-enforce-todo-checkbox-dependencies t))
#+end_src

**** Extensible Dependencies 'N' Actions (EDNA)
#+begin_src emacs-lisp :tangle packages.el
(package! org-edna)
#+end_src

#+begin_src emacs-lisp
(use-package! org-edna
  :defer t
  :commands (org-edna-mode)
  :init
  (after! org
    (org-edna-mode 1)))
#+end_src

*** Snippets
#+begin_src emacs-lisp :tangle packages.el
(package! yasnippets-org
  :recipe (:host github
           :repo "ezchi/yasnippets-org"
           :files ("*.el" ("snippets" ("org-mode" "snippets/org-mode/*")))))
#+end_src

*** Google calendar
#+begin_src emacs-lisp :tangle (if (ec/at-home-p) "yes" "no")
(use-package! org-gcal
  :commands (org-gcal-sync)
  :init
  (defvar ec/org-gcal-config-json (expand-file-name "gcal.json.gpg" doom-private-dir))
  :hook (org-agenda-mode . org-gcal-sync)
  :config
  (defun ec/get-gcal-config-value (key)
    "Return the value of org-gcal JSON config KEY."
    (let* ((json (cdr (assoc 'installed (json-read-file ec/org-gcal-config-json)))))
      (cdr (assoc key json))))

  (setq org-gcal-client-id (ec/get-gcal-config-value 'client_id)
        org-gcal-client-secret (ec/get-gcal-config-value 'client_secret)
        org-gcal-fetch-file-alist `(("Enze.Chi@gmail.com" . ,(expand-file-name "gcal.org.gpg" doom-private-dir)))))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! org-gcal)
#+end_src

** Python
Apply *python-mode* on =SConstruct=.
#+begin_src emacs-lisp
(use-package! python
  :mode ("SConstruct\\'" . python-mode)
  :config
  (setq python-shell-completion-native-enable nil))
#+end_src

** VHDL
*** Initialization
#+begin_src emacs-lisp
(after! vhdl-mode
  (defun ec-vhdl-init ()
    "Initial function which should be added to VHDL mode hook."
    (interactive)
    (setq-default
     vhdl-basic-offset 4
     vhdl-clock-edge-condition 'function
     vhdl-conditions-in-parenthesis t
     vhdl-end-comment-column 100
     vhdl-highlight-special-words t
     vhdl-highlight-translate-off t
     vhdl-highlight-verilog-keywords t
     vhdl-include-port-comments t
     vhdl-include-type-comments t
     vhdl-inline-comment-column 70
     vhdl-instance-name '(".*" . "i_\\&")
     vhdl-reset-active-high t
     vhdl-reset-kind 'sync
     vhdl-standard '(8 (math))
     vhdl-underscore-is-part-of-word t
     vhdl-upper-case-constants t
     vhdl-upper-case-enum-values nil)
    (add-to-list 'vhdl-offsets-alist '(arglist-close . 0))
    (advice-add 'lsp-hover :around #'ec-skip-lsp-hover-on-empty-line)))
#+end_src

*** VHDL-TOOL
Define vhdl-tool config file.
#+begin_src emacs-lisp
(defvar ec-vhdl-tool-config "vhdltool-config.yaml"
  "vhdl-tool config file")
#+end_src

Add =vhdl-tool= as flycheck checker.
#+begin_src emacs-lisp
(after! flycheck
  (flycheck-define-checker vhdl-tool
    "A VHDL syntax checker, type checker and linter using VHDL-Tool.
See `http://vhdltool.com'."
    :command ("vhdl-tool" "client" "lint" "--compact" source-original)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ":w:" (message) line-end)
     (error line-start (file-name) ":" line ":" column ":e:" (message) line-end))
    :modes vhdl-mode))
;; (add-to-list 'flycheck-checkers 'vhdl-tool)
#+end_src

I haven't found good solution to configure =vhdl-tool= as default checker. I
will try to do it in =.dir-local.el= as
#+begin_src emacs-lisp :tangle no
((vhdl-mode
  (flycheck-checker . 'vhdl-tool)))
#+end_src

Flycheck hook function to select =vhdl-tool= as checker.
#+begin_src emacs-lisp
(after! flycheck
  (defun ec-vhdl-setup-flycheck-after-lsp ()
    "Setup vhdl-tool as flycheck checker for VHDL mode"
    (when (eq major-mode 'vhdl-mode)
      (flycheck-select-checker 'vhdl-tool)
      (setq flycheck-checker 'vhdl-tool))))
#+end_src

Helper functions to start/stop =vhdl-tool= server for linting.
#+begin_src emacs-lisp
(defun ec-vhdl-tool--server-process-buffer-name ()
  "Get vhdl-tool server name for current project"
  (format "vhdl-tool server@%s" (projectile-project-root)))

(defun ec-vhdl-tool--server-start-p (buffer)
  "Return non-nil if the BUFFER associated process is started."
  (let ((process (get-buffer-process buffer)))
    (if process(eq (process-status (get-buffer-process buffer)) 'run)
      nil)))

(defun ec-vhdl-tool-stop-server ()
  "Stop vhdl-tool server if it is started."
  (interactive)
  (let ((buffer (ec-vhdl-tool--server-process-buffer-name)))
    (when (ec-vhdl-tool--server-start-p buffer)
      (kill-process (get-buffer-process buffer)))))

(defun ec-vhdl-tool-start-server ()
  "Start vhdl-tool server for linting."
  (interactive)
  (let* ((default-directory (projectile-project-root))
         (buffer (ec-vhdl-tool--server-process-buffer-name)))
    (unless (executable-find "vhdl-tool")
      (error "Can not find vhdl-tool"))
    (unless (file-exists-p ec-vhdl-tool-config)
      (error "Can not find %s @ %s" ec-vhdl-tool-config default-directory))
    (unless (ec-vhdl-tool--server-start-p buffer)
      (message "Starting vhdl-tool server")
      (start-process "vhdl-tool-sever" buffer "vhdl-tool" "server"))))
#+end_src

*** Hooks
Somehow the =lsp-vhdl= is broken from =lsp-mode=, create =lsp-client= manually
here until upstream fix it.
#+begin_src emacs-lisp
(after! lsp-mode
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection '("vhdl-tool" "lsp"))
                    :major-modes '(vhdl-mode)
                    :language-id "VHDL"
                    :priority -1
                    :server-id 'lsp-vhdl)))
#+end_src

#+begin_src emacs-lisp
(after! vhdl-mode
  (add-hook! vhdl-mode #'(ec-vhdl-init lsp! ec-vhdl-tool-start-server yas-minor-mode-on)))
#+end_src

*** yasnippets-vhdl
#+begin_src emacs-lisp
(use-package! yasnippets-vhdl
  :defer t)
#+end_src

*** Functions
vhdl-tool (v0.0.12 when added) would crash when get hover request on empty line.
Add advice function to skip =lsp-hover= on empty line.

**** ec--white-space-or-empty-line-p
#+begin_src emacs-lisp
(defun ec--whitespace-or-empty-line-p ()
  "Return non-nil if current line is empty or whitespaces only."
  (looking-at "^[[:space:]\n]*$"))
#+end_src

**** ec-skip-lsp-hover-on-empty-line
#+begin_src emacs-lisp
(defun ec-skip-lsp-hover-on-empty-line (f &rest args)
  "Skip lsp-hover on empty or whitespaces only lines."
  (if (ec--whitespace-or-empty-line-p)
      (setq lsp--hover-saved-bounds nil
            lsp--eldoc-saved-message nil)
    (apply f args)))
#+end_src

*** Key bindings
#+begin_src emacs-lisp
(after! vhdl-mode
  (map! :localleader
        :map vhdl-mode-map
        (:prefix ("t" . "+template")
         "ar" #'vhdl-template-architecture
         "at" #'vhdl-template-assert

         "bl" #'vhdl-template-block

         "ca" #'vhdl-template-case-is
         "co" #'vhdl-template-constant

         "ei" #'vhdl-template-elsif
         "el" #'vhdl-template-else
         "en" #'vhdl-template-entity

         "fb" #'vhdl-template-function-body
         "fd" #'vhdl-template-function-decl
         "fl" #'vhdl-template-for-loop

         "ge" #'vhdl-template-generic

         "fg" #'vhdl-template-for-generate
         "ig" #'vhdl-template-if-generate

         "it" #'vhdl-template-if-then

         "li" #'vhdl-template-library

         "pc" #'vhdl-template-process-comb
         "po" #'vhdl-template-port
         "ps" #'vhdl-template-process-seq

         "si" #'vhdl-template-signal
         "su" #'vhdl-template-subtype

         "ty" #'vhdl-template-type

         "us" #'vhdl-template-use

         "va" #'vhdl-template-variable

         "Pn" #'vhdl-template-package-numeric-std
         "Ps" #'vhdl-template-package-std-logic-1164
         )))
#+end_src
*** Packages
**** vhdl-mode
#+begin_src emacs-lisp :tangle packages.el
(package! vhdl-mode
  :recipe (:host github
           :repo "ezchi/vhdl-mode"
           :branch "ec-release"))
#+end_src

**** yasnippets-vhdl
#+begin_src emacs-lisp :tangle packages.el
(package! yasnippets-vhdl
  :recipe (:host github
           :repo "ezchi/yasnippets-vhdl"
           :files ("*.el" ("snippets" ("vhdl-mode" "snippets/vhdl-mode/*")))))
#+end_src

** Verilog
*** Flycheck
The =verilator= does not working well with verification code. Disable =verilog-verilator= checker until it usable.

#+begin_src emacs-lisp
(after! flycheck
  (delq! 'verilog-verilator flycheck-checkers))
#+end_src

*** verilog-mode
#+begin_src emacs-lisp
(use-package! verilog-mode
  :defer t
  :mode "\\.[s]?v[h]?\\'"
  :hook ((verilog-mode . disable-single-quote-sp-pair)
         (verilog-mode . lsp))
  :config
  (defun disable-single-quote-sp-pair ()
    "Disable single quote sp-pair which does not work well for verilog-mode.
It is bad example for automatically inserting single quote pair:
  a = 1'b0;
  b = '0;"
    (sp-local-pair 'verilog-mode "'" nil :actions nil))

  (require 'lsp)
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection '("svls"))
                    :major-modes '(verilog-mode)
                    :priority 1
                    :server-id 'lsp-svls))
  (add-to-list 'lsp-language-id-configuration '(verilog-mode . "verilog"))

  (require 'flycheck)
  (add-to-list 'flycheck-disabled-checkers 'verilog-verilator)

  (setq verilog-align-ifelse nil)
  (setq verilog-auto-indent-on-newline t)
  (setq verilog-auto-lineup 'assignments)
  (setq verilog-auto-newline nil)
  (setq verilog-case-indent 4)
  (setq verilog-cexp-indent 0)
  (setq verilog-debug t)
  (setq verilog-highlight-grouping-keywords t)
  (setq verilog-highlight-includes t)
  (setq verilog-highlight-modules t)
  (setq verilog-highlight-translate-off t)
  (setq verilog-indent-begin-after-if nil)
  (setq verilog-indent-declaration-macros nil)
  (setq verilog-indent-level 4)
  (setq verilog-indent-level-behavioral 4)
  (setq verilog-indent-level-declaration 4)
  (setq verilog-indent-level-module 4)
  (setq verilog-indent-lists t)
  (setq verilog-library-extensions '(".v" ".sv" ".svh"))
  (setq verilog-minimum-comment-distance 40)
  (setq verilog-tab-always-indent t)
  (setq verilog-typedef-regexp "[a-zA-Z0-9_]+_t"))
#+end_src
*** SystemVerilog Language Server
Use [[https://github.com/dalance/svls][svls]] as SystemVerilog Language Server.
#+begin_src emacs-lisp :tangle no
(after! lsp
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection '("svls"))
                    :major-modes '(verilog-mode)
                    :priority 1
                    :server-id 'lsp-svls))
  (add-to-list 'lsp-language-id-configuration '(verilog-mode . "verilog")))
#+end_src
*** yasnippets-verilog
#+begin_src emacs-lisp
(use-package! yasnippets-verilog
  :defer t)
#+end_src

#+begin_src emacs-lisp :tangle (if (ec/at-office-p) "yes" "no")
(use-package! yasnippets-opt-verilog
  :defer t)
#+end_src

*** Packages
**** verilog-mode
#+begin_src emacs-lisp :tangle packages.el
(package! verilog-mode
  :recipe (:host github
           :repo "ezchi/verilog-mode"
           :branch "lite"
           :files ("verilog-mode.el")
           :nonrecursive t))
#+end_src

**** yasnippets-verilog
#+begin_src emacs-lisp :tangle packages.el
(package! yasnippets-verilog
  :recipe (:host github
           :repo "ezchi/yasnippets-verilog"
           :files ("*.el" ("snippets" ("verilog-mode" "snippets/verilog-mode/*")))))
#+end_src

#+begin_src emacs-lisp :tangle (if (ec/at-office-p) "packages.el" "no")
(package! yasnippets-opt-verilog
  :recipe (:type git
           :repo "ssh://git@git:7999/~enzchi/yasnippets-opt-verilog.git"
           :files ("*.el" ("snippets" ("verilog-mode" "snippets/verilog-mode/*")))))
#+end_src

* Tools
** Git
*** git-auto-commit-mode
#+begin_src emacs-lisp :tangle no
(use-package! git-auto-commit-mode
  :commands (git-auto-commit-mode)
  :config
  (setq gac-debounce-interval 3600))
#+end_src

*** Packages
#+begin_src emacs-lisp :tangle no
(package! git-auto-commit-mode)
#+end_src
** GPG :noexport:
These are encrypted with gpg and are essentially set mostly by custom-*
#+begin_src emacs-lisp :tangle (if (ec/at-home-p) "yes" "no")
(use-package! epa-file
  :config
  (setenv "GPG_AGENT_INFO" nil)
  (epa-file-enable)
  (setq auth-sources `(,(expand-file-name ".authinfo.gpg" doom-private-dir))))
#+end_src

Enable this if need to debug the authentication issues.
#+begin_src emacs-lisp :tangle no
(setq auth-source-debug t)
#+end_src

** Optiver
*** optiver-fex
#+begin_src emacs-lisp :tangle (if (ec/at-office-p) "packages.el" "no")
(package! optiver-fex
  :recipe (:type git
           :repo "ssh://git@git:7999/~enzchi/optiver-fex.git"))
#+end_src

#+begin_src emacs-lisp :tangle (if (ec/at-office-p) "yes" "no")
(use-package! optiver-fex
  :commands (optiver-fex-rerun-previous-command optiver-fex-dispatch))
#+end_src
** Search
*** rg
Needs a solution to use =ripgrep= to search =gitignore= files in a project.

#+begin_src emacs-lisp
(use-package! rg
  :commands (rg rg-menu))

(map! :leader
      (:prefix ("zs" . "search")
       (:prefix ("r" . "rg search")
        :desc "rg-menu" "m" #'rg-menu
        :desc "rg" "r" #'rg)))
#+end_src

*** consel-fd
Search files with =fd=. So far this is best solution for me to search ignored files in a project.

#+begin_src emacs-lisp
(use-package! counsel-fd
  :commands (counsel-fd-dired-jump counsel-fd-file-jump)
  :init
  (setq counsel-fd-command "fd --hidden --color never -I "))

(map! :leader
      (:prefix ("zf" . "file")
       :desc "Find any file in project" "p" (cmd!! #'counsel-fd-file-jump '(4))))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! counsel-fd
  :recipe (:host github
           :repo "ezchi/counsel-fd"
           :branch "develop"))
#+end_src

** Text
*** Lorem Ipsum
Sometimes I need to generate random text to try things, such as Evil key bindings.
#+begin_src emacs-lisp :tangle packages.el
(package! lorem-ipsum)
#+end_src

#+begin_src emacs-lisp
(use-package! lorem-ipsum
  :commands (lorem-ipsum-insert-paragraphs
             lorem-ipsum-insert-sentences
             lorem-ipsum-insert-list)
  :defer t)
#+end_src

** Personal collections
*** ec-elisp-dumpground
Some Elisp code I am playing with and have no home for them yet.
#+begin_src emacs-lisp :tangle packages.el
(package! ec-elisp-dumpground
  :recipe (:host github
           :repo "ezchi/ec-elisp-dumpground"))
#+end_src

#+begin_src emacs-lisp
(use-package! ec-elisp-dumpground)
#+end_src

*** ecdate
#+begin_src emacs-lisp :tangle packages.el
(package! ecdate
  :recipe (:host github
           :repo "ezchi/ecdate"))
#+end_src

#+begin_src emacs-lisp
(use-package! ecdate)
#+end_src
* Email
#+begin_src emacs-lisp :tangle (if (ec/at-home-p) "yes" "no")
(after! mu4e
  (set-email-account! "Gmail"
                      '((mu4e-sent-folder       . "/[Gmail].Sent Mail")
                        (mu4e-drafts-folder     . "/[Gmail].Drafts")
                        (mu4e-trash-folder      . "/[Gmail].Trash")
                        (mu4e-refile-folder     . "/[Gmail].All Mail")
                        (smtpmail-smtp-server   . "smtp.gmail.com")
                        (smtpmail-smtp-service  . 587)
                        (smtpmail-smtp-user     . "Enze.Chi@gmail.com")
                        (mu4e-compose-signature . "\nEnze Chi"))
                      t))
#+end_src

Set bookmark for =Inbox= which excludes =Trash= folder

#+begin_src emacs-lisp :tangle (if (ec/at-home-p) "yes" "no")
(after! mu4e
  (add-to-list 'mu4e-bookmarks
               (make-mu4e-bookmark
                :name "Inbox"
                :query "maildir:/INBOX"
                :key ?i)))
#+end_src

Fetch for new email for every 5 minutes.
#+begin_src emacs-lisp :tangle (if (ec/at-home-p) "yes" "no")
(after! mu4e
  (setq mu4e-update-interval 300))
#+end_src

* Packages
** org-pandoc-import
[[https://github.com/tecosaur/org-pandoc-import][Org Pandoc Import]]

#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
#+end_src

** rg
#+begin_src emacs-lisp :tangle packages.el
(package! rg)
#+end_src

** aio
Try out asynchronous functions.

#+begin_src emacs-lisp
(use-package! aio)
#+end_src
#+begin_src emacs-lisp :tangle packages.el
(package! aio)
#+end_src

** async-wait
Try out [[https://github.com/chuntaro/emacs-async-await][Emacs async-await]].

#+begin_src emacs-lisp
(use-package! async-await)
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! async-await)
#+end_src
